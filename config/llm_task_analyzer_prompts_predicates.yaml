# Optional default robot description injected into prompts (set to null to omit)
robot_description: "The robot is a 7-DOF robot arm, with a two-finger rigid gripper as end effector. The end effector cannot grasp objects <1cm or >15cm. The robot has a Realsense RGBD camera mounted at the end effector."
analysis_prompt: |
  Your goal is to analyze a task space and formulate a symbolic world representation in
  PDDL that a robotics system can use to execute the task.

  You are given:

    Task description:
    <<TASK>>

    Robot description:
    <<ROBOT_DESCRIPTION>>

    Current observed objects:
    <<OBJECTS_JSON>>

    Current observed relationships:
    <<RELATIONSHIPS_JSON>>

  Ground your answer in the provided scene: use `object_id` values from the observations
  when listing goal_objects if they are already identified.

  You must respond with **valid JSON only**, following this schema:

  {
    "relevant_predicates": [
      "<predicate_signature_1>",
      "<predicate_signature_2>",
      "..."
    ],
    "relevant_actions": [
      {
        "name": "<action_name_1>",
        "parameters": ["<param_var_1>", "<param_var_2>", "..."],
        "precondition": "<pddl_precondition_formula>",
        "effect": "<pddl_effect_formula>"
      },
      {
        "name": "<action_name_2>",
        "parameters": ["<param_var_1>", "..."],
        "precondition": "<pddl_precondition_formula>",
        "effect": "<pddl_effect_formula>"
      }
    ],
    "goal_predicates": [
      "<pddl_goal_condition_1>",
      "<pddl_goal_condition_2>",
      "..."
    ],
    "preconditions": ["(predicate obj)", "..."],
    "initial_predicates": ["(current_predicate obj)", "..."],
    "goal_objects": ["object_id1", "..."],
    "global_predicates": ["global_predicate1", "..."],
  }

  Response guidelines:

  1. **Purpose.**
    Your goal is *not* to complete the task, but to propose a useful, general set of
    symbolic primitives (predicates, actions, and goal conditions) that a downstream
    planner can use to build a world model and operate on it.

  2. **Relevant predicates.**
  - `relevant_predicates` should be a detailed and exhaustive list of predicates that
    might be useful for representing and solving the task.
  - **IMPORTANT**: Provide predicates with their parameters in PDDL format, e.g.:
      - `(clear ?obj)` - unary predicate
      - `(on ?item ?surface)` - binary predicate
      - `(empty-hand)` - zero-parameter predicate
      - `(is_cup ?obj)` - unary classification predicate
  - Include:
      - **Relational predicates** (e.g. spatial, containment, support, reachability,
        state—such as `(on ?x ?y)`, `(inside ?x ?y)`, `(open ?x)`, `(plugged_in ?x)`), and
      - **Semantic / classification predicates** that label objects by their role or type
        (e.g. `(is_cup ?x)`, `(is_table ?x)`, `(is_container ?x)`, `(is_button ?x)`), which
        will later be evaluated from perception and object attributes.
      Add all semantic predicates that are relevant to the task, world, or goal description
      so that downstream planners can bind those categories during grounding.
  - **CRITICAL**: The name of the predicate is the unique identifier for a predicate, and should
  be consistently used throughout, with the correct number of arguments.

  3. **Relevant actions.**
    - `relevant_actions` is a list of actions the robot is in principle capable of,
      given the robot description (e.g. `pick`, `place`, `move_to`, `open`, `close`,
      `press_button`, `pour`, `plug_in`, etc.).
    - For each action:
      - `name` is a short PDDL-style action name, containing no spaces and using underscore
        to separate words.
      - `parameters` is a list of variables, each given as a string like `"?obj"` or `"?src"`.
      - `precondition` is a single PDDL formula string using only predicates from 
        `relevant_predicates`.
      - `effect` is a single PDDL formula string (again typically an `(and ...)`
        expression) specifying both positive and negative effects, using only predicates
        from `relevant_predicates`.
    - Predicates in preconditions and effects should use the exact same number of parameters
      as defined in `relevant_predicates`. For example:
      - If you define `(holding ?obj)` in predicates (1 parameter)
      - Then you MUST use `(holding ?x)` in actions (1 parameter)
      - NEVER use `(holding)` (0 parameters) or `(holding ?x ?y)` (2 parameters)
    - If you introduce a predicate in any action's precondition or effect that is not yet
      in `relevant_predicates`, you **must** add its full signature to
      `relevant_predicates`.

  4. **Goal predicates.**
    - `goal_predicates` should describe the intended task outcome as *general,
      quantificational conditions over the world*, **not** as facts about specific
      named objects.
    - Express goals in terms of:
      - Semantic predicates that classify objects (e.g. `is_container`, `is_tool`,
        `is_target_object`), and
      - Relational predicates that describe how these objects should be arranged or
        configured (e.g. `inside`, `on`, `connected`, `activated`).
    - Each element of `goal_predicates` should be a PDDL condition string suitable for a
      `:goal` field. You may use logical connectives (`and`, `or`, `not`) and quantifiers
      (`exists`, `forall`) when needed.
    - Use proper PDDL syntax with parentheses. CORRECT examples:
      - `(coffee-made ?cup)` - correct
      - `(inside ?obj1 ?obj2)` - correct
      Wrong examples:
      - `coffee-made(?cup)`
      - `coffee-made ?cup`
      - `inside(?obj1, ?obj2)`

    For example, instead of directly naming concrete constants like:
      “the water bottle is in the paper bag”,

    you should express the goal as a quantificational condition over abstract objects,
    such as:

      In logical form:
        “There exist objects w and b such that
          is_water_bottle(w) ∧ is_paper_bag(b) ∧ inside(w, b).”

      In PDDL-style syntax (goal condition only):
        (exists (?w ?b)
          (and (is_water_bottle ?w)
                (is_paper_bag ?b)
                (inside ?w ?b)))

    This way, the goal does **not** refer to any particular object names that may only be
    introduced later in the problem file. It is written purely in terms of semantic and
    relational predicates over abstract objects.

    For broader household instructions (e.g., “clear the counter”), write conditions that
    universally quantify over semantic categories:

      Logical sketch:
        “For every movable object m on a counter c, ensure the counter ends up clear:
          is_kitchen_counter(c) ∧ (on_surface(m, c) → relocated(m)).”

    These formulations stay agnostic to specific object in the world, while still encoding the
    semantic intent of the task through predicate structure.

  5. **Global and initial predicates.**
    - `global_predicates` describe robot/environment state that should be TRUE before task execution (e.g., `hand_is_empty`, `arm_at_home`, `gripper_open`, `robot_ready`).
    - Do NOT include object-related facts in `global_predicates`; place those in `initial_predicates`.
    - Global predicates typically have no parameters (or take the robot as the sole parameter) and should be returned without parentheses.

  6. **PDDL formatting rules (apply everywhere).**
    - Parameters MUST use variables with ? prefix (e.g., `?obj`, `?location`, `?machine`).
    - Keep everything untyped: do not include `- object`, `- surface`, or any other type annotations.
    - Preconditions and effects can ONLY use variables and predicate names; NEVER include quoted strings or constants.
    - Represent components as predicates, not strings:
      - WRONG: `(is-empty ?machine "water_reservoir")`
      - RIGHT: `(water-reservoir-empty ?machine)` or `(reservoir-has-water ?machine)`
    - Use hyphens for multi-word predicates (e.g., `has-water`, `water-reservoir-empty`).

  7. **Arity consistency example.**
    Here is a CORRECT example showing consistent predicate arity:

    {
      "relevant_predicates": [
        "(holding ?obj)",
        "(empty-hand)",
        "(on ?obj ?surface)",
        "(graspable ?obj)"
      ],
      "relevant_actions": [
        {
          "name": "pick",
          "parameters": ["?obj"],
          "precondition": "(and (empty-hand) (graspable ?obj))",
          "effect": "(and (holding ?obj) (not (empty-hand)))"
        },
        {
          "name": "place",
          "parameters": ["?obj", "?surface"],
          "precondition": "(holding ?obj)",
          "effect": "(and (on ?obj ?surface) (empty-hand) (not (holding ?obj)))"
        }
      ]
    }

    Notice how:
    - `(holding ?obj)` is defined with 1 parameter
    - `(holding ?obj)` is used with 1 parameter in precondition and effect
    - `(empty-hand)` is defined with 0 parameters
    - `(empty-hand)` is used with 0 parameters everywhere
    - The parameter names can differ (?obj, ?x, ?item) but the COUNT must match

  8. **VERIFICATION STEPS (complete these BEFORE returning your response).**
    Step 1: List ALL predicates you defined in `relevant_predicates`
    Step 2: For EACH action in `relevant_actions`:
      a) Extract all predicates from precondition
      b) Extract all predicates from effect
      c) For each predicate usage, count its parameters
      d) Find its definition in `relevant_predicates`
      e) VERIFY the parameter count EXACTLY matches
      f) If mismatch, FIX the action OR add missing predicate definition
    Step 3: Ensure every predicate used exists in `relevant_predicates`
    Step 4: Check all PDDL syntax is correct (parentheses, spaces, no commas)
    Step 5: Confirm global_predicates follow the rules above (no object-specific entries, no parentheses)

    Example verification for action "pick":
    - Precondition uses: `(empty-hand)` → 0 params
    - Check definition: `(empty-hand)` → 0 params ✓ MATCH
    - Precondition uses: `(graspable ?obj)` → 1 param
    - Check definition: `(graspable ?obj)` → 1 param ✓ MATCH
    - Effect uses: `(holding ?obj)` → 1 param
    - Check definition: `(holding ?obj)` → 1 param ✓ MATCH

  9. **Output format.**
    - Return **only** the JSON object described above.
    - Do **not** include comments, explanations, or any text outside the JSON.
