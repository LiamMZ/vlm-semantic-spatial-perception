# Optional default robot description injected into prompts (set to null to omit)
robot_description: "The robot is a 7-DOF robot arm, with a two-finger rigid gripper as end effector. The end effector cannot grasp objects <1cm or >15cm. The robot has a Realsense RGBD camera mounted at the end effector."

analysis_prompt: |
  Your goal is to analyze a task space and formulate a symbolic world representation in
  PDDL that a robotics system can use to execute the task.

  You are given:

    Task description:
    <<TASK>>

    Robot description:
    <<ROBOT_DESCRIPTION>>

    Current observed objects:
    <<OBJECTS_JSON>>

    Current observed relationships:
    <<RELATIONSHIPS_JSON>>

  Ground your answer in the provided scene: use `object_id` values from the observations
  when listing goal_objects, and express goal_predicates as literals over those goal_objects
  (no quantifiers or abstract variables).

  You must respond with **valid JSON only**, following this schema:

  {
    "relevant_predicates": [
      "<predicate_signature_1>",
      "<predicate_signature_2>",
      "..."
    ],
    "relevant_actions": [
      {
        "name": "<action_name_1>",
        "parameters": ["<param_var_1>", "<param_var_2>", "..."],
        "precondition": "<pddl_precondition_formula>",
        "effect": "<pddl_effect_formula>"
      },
      {
        "name": "<action_name_2>",
        "parameters": ["<param_var_1>", "..."],
        "precondition": "<pddl_precondition_formula>",
        "effect": "<pddl_effect_formula>"
      }
    ],
    "goal_predicates": [
      "<goal_literal_1>",
      "<goal_literal_2>",
      "..."
    ],
    "preconditions": ["(predicate obj)", "..."],
    "initial_predicates": ["(current_predicate obj)", "..."],
    "goal_objects": ["object_id1", "..."],
    "global_predicates": ["global_predicate1", "..."],
  }

  Response guidelines:

  1. **Purpose.**
    Your goal is *not* to complete the task, but to propose a useful, general set of
    symbolic primitives (predicates, actions, and goal conditions) that a downstream
    planner can use to build a world model and operate on it.

  2. **Relevant predicates.**
  - `relevant_predicates` should be a detailed and exhaustive list of predicates that
    might be useful for representing and solving the task.
  - **IMPORTANT**: Provide predicates with their parameters in PDDL format, e.g.:
      - `(clear ?obj)` - unary predicate
      - `(on ?item ?surface)` - binary predicate
      - `(empty-hand)` - zero-parameter predicate
      - `(is_cup ?obj)` - unary classification predicate
  - Include both:
      - **Relational predicates** (e.g. spatial, containment, support, reachability,
        stateâ€”such as `(on ?x ?y)`, `(inside ?x ?y)`, `(open ?x)`, `(plugged_in ?x)`), and
      - **Semantic / classification predicates** that label objects by their role or type
        (e.g. `(is_cup ?x)`, `(is_table ?x)`, `(is_container ?x)`, `(is_button ?x)`), which
        will later be evaluated from perception and object attributes.
      Add all semantic predicates that are relevant to the task, world, or goal description
      so that downstream planners can bind those categories during grounding.
  - **CRITICAL**: The parameter count in predicate definitions MUST match how they're used in actions.
      Example: If you define `(graspable ?obj)`, then use `(graspable ?x)` in actions, not `(graspable)`.
  - Align predicates with observed affordances and task requirements; avoid generic placeholders.

  3. **Relevant actions.**
    - `relevant_actions` is a list of actions the robot is in principle capable of,
      given the robot description (e.g. `pick`, `place`, `move_to`, `open`, `close`,
      `press_button`, `pour`, `plug_in`, etc.).
    - For each action:
      - `name` is a short PDDL-style action name (no spaces).
      - `parameters` is a list of variables, each given as a string like `"?obj"` or `"?src"`.
      - `precondition` is a single PDDL formula string (often an `(and ...)` expression)
        using only predicates from `relevant_predicates`.
      - `effect` is a single PDDL formula string (again typically an `(and ...)`
        expression) specifying both positive and negative effects, using only predicates
        from `relevant_predicates`.
    - **CRITICAL ARITY RULE**: Every predicate used in preconditions and effects MUST use
      the EXACT same number of parameters as defined in `relevant_predicates`. For example:
      - If you define `(holding ?obj)` in predicates (1 parameter)
      - Then you MUST use `(holding ?x)` in actions (1 parameter)
      - NEVER use `(holding)` (0 parameters) or `(holding ?x ?y)` (2 parameters)
    - If you introduce a predicate in any action's precondition or effect that is not yet
      in `relevant_predicates`, you **must** add its full signature to
      `relevant_predicates`.

  4. **Goal predicates.**
    - `goal_predicates` should describe the intended task outcome as literal facts about
      the `goal_objects` (use their observed object_ids), not quantified/abstract
      conditions. Examples:
        - `(inside bottle_1 bag_2)`
        - `(on cup_3 table_1)`
    - Avoid quantifiers and abstract placeholders; write direct literals over the goal_objects list.
    - Use only predicates that appear in `relevant_predicates`.

  5. **Global and initial predicates.**
    - `global_predicates` describe robot/environment state that should be TRUE before task execution (e.g., `hand_is_empty`, `arm_at_home`, `gripper_open`, `robot_ready`).
    - Do NOT include object-related facts in `global_predicates`; place those in `initial_predicates`.
    - Global predicates typically have no parameters (or take the robot as the sole parameter) and should be returned without parentheses.

  6. **PDDL formatting rules (apply everywhere).**
    - Parameters MUST use variables with ? prefix (e.g., `?obj`, `?location`, `?machine`) and keep everything untyped (no `- object` or other type annotations).
    - Preconditions and effects can ONLY use variables and predicate names; NEVER include quoted strings or constants.
    - Represent components as predicates, not strings:
      - WRONG: `(is-empty ?machine "water_reservoir")`
      - RIGHT: `(water-reservoir-empty ?machine)` or `(reservoir-has-water ?machine)`
    - Use hyphens for multi-word predicates (e.g., `has-water`, `water-reservoir-empty`).

  7. **Arity consistency example.**
    Here is a CORRECT example showing consistent predicate arity:

    {
      "relevant_predicates": [
        "(holding ?obj)",
        "(empty-hand)",
        "(on ?obj ?surface)",
        "(graspable ?obj)"
      ],
      "relevant_actions": [
        {
          "name": "pick",
          "parameters": ["?obj"],
          "precondition": "(and (empty-hand) (graspable ?obj))",
          "effect": "(and (holding ?obj) (not (empty-hand)))"
        },
        {
          "name": "place",
          "parameters": ["?obj", "?surface"],
          "precondition": "(holding ?obj)",
          "effect": "(and (on ?obj ?surface) (empty-hand) (not (holding ?obj)))"
        }
      ]
    }

    Notice how:
    - `(holding ?obj)` is defined with 1 parameter
    - `(holding ?obj)` is used with 1 parameter in precondition and effect
    - `(empty-hand)` is defined with 0 parameters
    - `(empty-hand)` is used with 0 parameters everywhere
    - The parameter names can differ (?obj, ?x, ?item) but the COUNT must match

  8. **VERIFICATION STEPS (complete these BEFORE returning your response).**
    Step 1: List ALL predicates you defined in `relevant_predicates`
    Step 2: For EACH action in `relevant_actions`:
      a) Extract all predicates from precondition
      b) Extract all predicates from effect
      c) For each predicate usage, count its parameters
      d) Find its definition in `relevant_predicates`
      e) VERIFY the parameter count EXACTLY matches
      f) If mismatch, FIX the action OR add missing predicate definition
    Step 3: Ensure every predicate used exists in `relevant_predicates`
    Step 4: Check all PDDL syntax is correct (parentheses, spaces, no commas)
    Step 5: Confirm global_predicates follow the rules above (no object-specific entries, no parentheses)
