# Agent Journal – 2025-11-22

Daily log of agent experiments, bug investigations, and operational incidents.

---

### 2025-11-22-1441 – Refactored ObjectTracker to use configurable prompts from YAML

- **Owner**: AI Agent (refactoring)
- **Agents affected**: ObjectTracker, VLM perception pipeline
- **Git commit(s)**: Based on dca9c84fdc1c59ef44d1b769bd293458038ff96f
- **Context**: User identified that `src/perception/object_tracker.py` hardcoded all VLM prompts as strings in the code (~150 lines). This made experimentation difficult and violated separation of concerns. Also discovered and removed unused `config/vlm_config.yaml` that was documented but never integrated.
- **Actions**:
  - **Created `config/prompts_config.yaml`**: Comprehensive prompt configuration with sections for detection (streaming/batch), analysis (fast/cached/full modes), interaction updates, and PDDL templates (171 lines)
  - **Modified `src/perception/object_tracker.py`**: 
    - Added `yaml` import and `prompts_config_path` constructor parameter
    - Loads prompts from YAML in `__init__` (defaults to `config/prompts_config.yaml`)
    - Replaced all 6 hardcoded prompt strings with `self.prompts` dictionary references
    - Used `.format()` for dynamic variable substitution
    - Net: +12 lines, -135 lines of hardcoded strings
  - **Created `docs/prompts_configuration.md`**: Complete guide covering structure, usage, customization, PDDL integration, troubleshooting (220 lines)
  - **Created `examples/custom_prompts_demo.py`**: Working demo with 4 scenarios: default config, custom kitchen prompts, PDDL predicates, runtime inspection (330 lines)
  - **Updated `README.md`**: Added prompts configuration section with usage examples and links
  - **Cleanup**: Deleted unused `config/vlm_config.yaml` and removed mention from `README.md`
- **Result**: 
  - Prompts now configurable via YAML without code changes
  - Easy domain-specific customization (e.g., kitchen, workshop)
  - Better maintainability and version control
  - Fully backward compatible
  - Demo runs successfully: `uv run python examples/custom_prompts_demo.py`
- **Next steps**: 
  - Consider creating domain-specific prompt configs (kitchen, workshop, lab)
  - Monitor for performance of different prompt formulations
  - Potentially add schema validation for prompt configs
- **References**: 
  - `config/prompts_config.yaml`
  - `src/perception/object_tracker.py` (lines 13, 86-101, 273-372, 434-533, 757-773)
  - `docs/prompts_configuration.md`
  - `examples/custom_prompts_demo.py`

---

### 2025-11-22-1534 – Merged ContinuousPDDLIntegration into TaskOrchestrator

- **Owner**: AI Agent (refactoring)
- **Agents affected**: TaskOrchestrator, continuous_pddl_integration_demo
- **Git commit(s)**: Based on 95f3b83f7497da4013eaee2bf609bebe18b9d3dc
- **Context**: User requested merging two similar orchestration classes (`TaskOrchestrator` and `ContinuousPDDLIntegration`) to eliminate duplication and make the demo app use the production-focused orchestrator. Also requested: (1) orchestrator should use tracker's registry directly for consistency, and (2) auto-save should be event-driven instead of timer-based.
- **Actions**:
  - **Modified `config/orchestrator_config.py`**: 
    - Replaced `auto_save_interval: float = 30.0` with event-driven flags
    - Added `auto_save_on_detection: bool = True` – save after each detection update
    - Added `auto_save_on_state_change: bool = True` – save on state changes
    - Added `on_save_state: Optional[Callable[[Path], None]]` callback
  - **Modified `src/planning/task_orchestrator.py`**:
    - **Removed separate registry**: Deleted `self.registry: DetectedObjectRegistry` instance
    - **Use tracker's registry**: All registry operations now use `self.tracker.registry` directly
    - **Removed timer-based auto-save**: Deleted `_auto_save_loop()` and `_auto_save_task`
    - **Implemented event-driven save**: Added `_try_auto_save()` with async lock to prevent concurrent saves
    - **Save on detection**: Calls `_try_auto_save()` in `_on_detection_callback()` if `auto_save_on_detection`
    - **Save on state change**: Calls `_try_auto_save()` in `_set_state()` if `auto_save_on_state_change`
    - **Added object tracking**: Added `_known_object_ids: set` and `get_new_objects()` method for demo reporting
    - **Updated all registry access**: Modified `get_detected_objects()`, `get_objects_by_type()`, `get_objects_with_affordance()`, `save_state()`, `load_state()`, `get_status()`, `__repr__()` to use tracker's registry
  - **Modified `examples/continuous_pddl_integration_demo.py`**:
    - **Removed `ContinuousPDDLIntegration` class**: Deprecated entire 475-line integration class
    - **Replaced with TaskOrchestrator**: App now instantiates and uses `TaskOrchestrator` directly
    - **Updated imports**: Changed to use `TaskOrchestrator`, `OrchestratorState`, `TaskState`, `OrchestratorConfig`
    - **Replaced event system**: Converted unified `on_event` callback to specific orchestrator callbacks:
      - `_on_state_change(old_state, new_state)` – logs state transitions
      - `_on_detection_update(object_count)` – logs detection cycles with new objects
      - `_on_task_state_change(decision)` – logs task readiness changes
      - `_on_save_state(path)` – silent for auto-saves to avoid log spam
    - **Updated commands**: 
      - `stop` → calls `orchestrator.stop_detection()`
      - Added `pause` → calls `orchestrator.pause_detection()`
      - `continue` → calls `orchestrator.resume_detection()`
      - `restart` → calls `orchestrator.shutdown()` then re-initializes
      - `save`/`load`/`generate` → use orchestrator methods
    - **Updated status display**: Adapted `_display_status()` to orchestrator's status structure
    - **Demo-specific logic**: Kept new object tracking, detailed logging, and TUI-specific formatting in app layer
- **Result**:
  - Single source of truth: TaskOrchestrator is now the only orchestration component
  - Consistent object registry between perception and planning (no duplication)
  - Auto-save triggers on actual events (detections, state changes) instead of arbitrary timer
  - Demo app is now a thin UI layer on top of production orchestrator
  - Cleaner separation: orchestrator = core logic, app = demo/UI concerns
  - Syntax validated: `python -m py_compile` passes
- **Breaking changes**:
  - `ContinuousPDDLIntegration` class removed from demo (deprecated, not part of public API)
  - `OrchestratorConfig.auto_save_interval` removed (replaced with event flags)
  - TaskOrchestrator no longer maintains separate registry (uses tracker's)
- **Next steps**:
  - Test demo with real camera hardware to ensure orchestrator integration works
  - Verify auto-save triggers appropriately on detection updates
  - Consider adding configurable save throttling to avoid excessive saves
- **References**:
  - `config/orchestrator_config.py` (lines 40-51)
  - `src/planning/task_orchestrator.py` (lines 26-27, 114-120, 140-211, 415-427, 544-571, 621-678, 726-752)
  - `examples/continuous_pddl_integration_demo.py` (entire file refactored)

---

### 2025-11-22-1546 – Demo UI refinements (rename, concise logs, better load)

- **Owner**: AI Agent (UI refinement)
- **Agents affected**: Orchestrator demo TUI
- **Git commit(s)**: Based on 95f3b83f7497da4013eaee2bf609bebe18b9d3dc
- **Context**: User requested cleaner detection logs, better naming, and flexible state loading
- **Actions**: (1) Renamed demo file/class: `continuous_pddl_integration_demo.py` → `orchestrator_demo.py`, (2) Detection updates now one-liners vs 10+ lines with separators, (3) `load [dir]` loads from external dir while saving to current
- **Result**: Cleaner logs, better naming. Run: `uv run examples/orchestrator_demo.py`
- **References**: `examples/orchestrator_demo.py`

---

### 2025-11-22-1548 – Fixed text wrapping in log panel

- **Owner**: AI Agent (bug fix)
- **Agents affected**: Orchestrator demo TUI
- **Git commit(s)**: Based on 95f3b83f7497da4013eaee2bf609bebe18b9d3dc
- **Context**: Long lines cropped instead of wrapping. Textual Log widget doesn't support CSS text wrapping
- **Actions**: Implemented programmatic wrapping using Python's `textwrap` module in `_write_log()` method. Calculates console width and wraps before writing
- **Result**: Text wraps at console boundaries dynamically. File logs stay unwrapped
- **References**: `examples/orchestrator_demo.py` (lines 18, 630-680)

---

### 2025-11-22-1614 – Switched log panel to RichLog for bold formatting

- **Owner**: AI Agent (UI/devex fix)
- **Agents affected**: Orchestrator demo TUI
- **Git commit(s)**: Based on 95f3b83f7497da4013eaee2bf609bebe18b9d3dc
- **Context**: Detection updates used `[bold]` markup in logs, but the `Log` widget did not render formatting; version was displaying markup literally.
- **Actions**:
    - Switched all log panel usage from `Log` to `RichLog` (`markup=True`), updated imports and type hints, switched `.write_line()` to `.write()`, and set `overflow-x: hidden`.
- **Result**: Log lines now correctly display bolded object names and formatted markup in the detection UI. Demo log output matches intended styling, no markup artifacts remain.
- **References**: `examples/orchestrator_demo.py` (lines 11, 53–79, 103, 135, 142, 676, 682)

---

### 2025-11-22-1730 – Orchestrator observation snapshots + perception pool integration

- **Owner**: AI Agent (feature implementation)
- **Agents affected**: TaskOrchestrator, OrchestratorConfig, Perception (registry), Journal/docs
- **Git commit(s)**: Based on efd3e0d18a970a65e72155bc4a27582aafee5e3e
- **Context**: We needed reproducible, queryable observations that planners and debugging tools can reuse after the fact. The orchestrator now captures an “observation snapshot” on a schedule (default: every detection) consisting of aligned RGB(-D), camera intrinsics, and the current object detections. Each snapshot is stored in a file-backed “perception pool” and indexed so we can:
  - Re-acquire objects later (feed recent images to re-detection or planning).
  - Build approach motions using saved depth and intrinsics without re-capturing.
  - Interpret past detections in robot/base/world frames using recorded robot state.
  - Audit/compare perception across runs for regressions.
  This is additive and non-breaking: existing `registry.json`/PDDL outputs are unchanged. Storage is bounded via retention, dependencies remain minimal (numpy/PIL/stdlib), and writes are serialized with an async lock. To avoid coupling to any single robot stack, robot context is provided via a duck-typed `get_robot_state()` so providers can emit whatever structured state they have (joints, TCP, extrinsics, etc.). Snapshots are enabled by default and taken every detection; when no provider is supplied, we attach the xArm cuRobo interface by default (best effort).
- **Actions**:
  - Config additions (`config/orchestrator_config.py`):
    - Added snapshot controls: `enable_snapshots`, `snapshot_every_n_detections`, `perception_pool_dir`, `max_snapshot_count`, `depth_encoding`, `robot`. Defaults: `enable_snapshots=True`, `snapshot_every_n_detections=1` (save on every detection), `max_snapshot_count=200`, `depth_encoding="npz"`.
  - Orchestrator integration (`src/planning/task_orchestrator.py`):
    - Added perception pool helpers and in-memory index (`_perception_pool_index`, `_perception_pool_lock`) with `index.json` persisted under `state_dir/perception_pool/`.
    - Implemented `save_snapshot(reason: str = "", label: Optional[str] = None)`:
      - Captures `color.png` (PNG, lossless), optional `depth.npz` (float32 meters), `intrinsics.json`, `detections.json`, `manifest.json`.
      - Generates human-sortable `SNAPSHOT_ID = YYYYMMDD_HHMMSS_mmm-<shortid>`, records `captured_at`/`recorded_at`.
      - Detections derive from the current registry with `object_id`, `object_type`, `affordances`, `pddl_state`, `position_3d`, `bounding_box_2d` if present.
      - Robot context via duck-typed `get_robot_state()` (no fixed schema) to `robot_state.json` when provider is attached.
    - Perception pool index maintenance:
      - `objects[object_id] -> [snapshot_ids]`, `snapshots[id]` summarizing files/objects/times, `last_snapshot_id`.
      - Enforced retention (`max_snapshot_count`) by pruning oldest snapshot folders and index entries.
    - Auto-trigger snapshots from `_on_detection_callback` per `snapshot_every_n_detections` (default = 1). Trigger does not require objects to be present.
    - State persistence:
      - `save_state()` now includes `files["perception_pool_index"]` when present and `last_snapshot_id` at root.
      - `load_state()` preloads the index if present and restores `last_snapshot_id`.
    - Default robot provider:
      - If `config.robot` is `None`, attempt to attach `CuRoboMotionPlanner` by default (graceful failure if not available).
  - xArm provider (`src/kinematics/xarm_curobo_interface.py`):
    - Added `get_robot_state()` returning a JSON-serializable dict with available fields (e.g., timestamp, joints, TCP pose, camera transform, optional static camera); fields omitted when unavailable.
- **Notes/Deviations from plan**:
  - The original plan included separate `extrinsics.json` with `T_base_camera`. We generalized to a provider-defined `get_robot_state()` to avoid schema lock-in; providers may include extrinsics inside that payload if desired.
  - All paths remain relative under `perception_pool/` and formats remain PNG/NPZ/JSON as specified.
- **Testing**:
  - Manual: Enabled snapshots and verified files/indices created under `outputs/orchestrator_state/perception_pool/` during detection callbacks.
  - Next: Add a synthetic-frame example to call `save_snapshot()` once and verify folder/index contents; test default xArm provider on hardware.
- **Risks/Mitigations**:
  - Storage growth: Retention enforced by `max_snapshot_count` (default 200); users can tune or disable.
  - Provider variability: Orchestrator uses duck-typed `get_robot_state()` and tolerates missing fields.
  - Behavior change: Snapshots are enabled by default and run every update; users can revert via config.
- **References**:
  - `agents/design/orchestrator_observation_snapshot_plan.md`
  - `config/orchestrator_config.py`
  - `src/planning/task_orchestrator.py`
  - `src/kinematics/xarm_curobo_interface.py`
  - `docs/ORCHESTRATOR.md` (diagram cross-link pending)

---

### 2025-11-22-1740 – Fixed robot state null issue and registry position grounding

- **Owner**: AI Agent (bug fix + architectural improvement)
- **Agents affected**: TaskOrchestrator, ObjectRegistry, orchestrator_demo
- **Git commit(s)**: Based on efd3e0d18a970a65e72155bc4a27582aafee5e3e
- **Context**: User reported two issues with `outputs/pddl/continuous_20251122_173331/`:
  1. **Robot state was null** in snapshot manifests despite robot being present - initialization messages weren't visible in logs
  2. **Registry positions not tied to snapshots** - `registry.json` stored `position_2d`/`position_3d`/`bounding_box_2d` at object level (latest values only), losing spatial history and not grounding positions in specific perceptions
- **Root causes**:
  1. Robot initialization happens during `orchestrator.initialize()` before log file is created; stdout messages weren't captured by TUI
  2. Registry was designed as a generic object store, unaware of snapshot context - positions were "current state" only, not tied to observation history
- **Actions**:
  - **Demo log capture** (`examples/orchestrator_demo.py`):
    - Moved log file setup before orchestrator initialization (line ~418)
    - Added stdout capture using `io.StringIO` during `orchestrator.initialize()` to capture robot provider messages
    - Writes captured init output to log widget and file with proper indentation
  - **Registry format v2.0** (`src/planning/task_orchestrator.py`):
    - Created `_build_enhanced_registry()` method that loads perception pool index and adds snapshot references to each object
    - Registry now includes:
      - `observations: [snapshot_ids]` - full observation history
      - `latest_observation: snapshot_id` - most recent snapshot containing this object
      - `latest_position_2d/3d/bounding_box_2d` - convenience fields from latest detection
      - Interaction points now include `snapshot_id` to ground them in specific perceptions
    - Added `version: "2.0"` and explanatory note about looking up full position history in `perception_pool/snapshots/<id>/detections.json`
    - Updated `save_state()` to use enhanced registry format
  - **Backward compatibility** (`src/perception/object_registry.py`):
    - Updated `load_from_json()` to handle both v1.0 (old `position_*`) and v2.0 (new `latest_position_*`) formats
    - Detects format version and maps fields accordingly
    - Logs format version when loading
- **Result**:
  - **Robot state visibility**: Demo now captures and displays robot initialization messages including success/failure of default provider attachment
  - **Position grounding**: Registry positions are now explicitly tied to snapshot IDs, making it clear which perception generated each position. Full position history available by traversing `observations[]` and looking up each snapshot's `detections.json`
  - **No breaking changes**: Old registry files (v1.0) still load correctly; v2.0 format is additive
  - **Architectural clarity**: Registry is now the "what was observed" summary with references to "when/where" in snapshots; snapshots are the detailed perception records
- **Next steps**:
  - Test with real robot to verify robot_state.json is populated
  - Consider adding helper method to look up object positions across all snapshots
  - Document new registry format in `docs/ORCHESTRATOR.md`
- **References**:
  - `examples/orchestrator_demo.py` (lines 390-449)
  - `src/planning/task_orchestrator.py` (lines 985-1055, enhanced registry method)
  - `src/perception/object_registry.py` (lines 288-350, backward compatibility)

---

### 2025-11-22-1802 – Removed v1.0 compatibility from ObjectRegistry

- **Owner**: AI Agent (cleanup)
- **Agents affected**: ObjectRegistry
- **Git commit(s)**: Based on efd3e0d18a970a65e72155bc4a27582aafee5e3e
- **Context**: The `ObjectRegistry.load_from_json()` method had backward compatibility code to support both v1.0 (using `position_2d`, `position_3d`, `bounding_box_2d`) and v2.0 (using `latest_position_2d`, `latest_position_3d`, `latest_bounding_box_2d`) registry formats. Since the codebase has fully transitioned to v2.0, the v1.0 compatibility layer is no longer needed.
- **Actions**:
  - **Modified `src/perception/object_registry.py`**:
    - Removed version detection logic (`version = data.get("version", "1.0")`)
    - Removed conditional branching for v1.0 vs v2.0 field names
    - Now only supports v2.0 format with `latest_position_*` fields
    - Updated docstring to remove mention of dual format support
    - Simplified success message to remove version mention
- **Result**:
  - Cleaner, simpler code with single format support
  - v1.0 registry files will no longer load (breaking change for old state files)
  - Reduced maintenance burden
- **Breaking changes**:
  - Old v1.0 registry JSON files will fail to load correctly (missing `latest_position_*` fields)
- **Next steps**:
  - Document v2.0 registry format in `docs/ORCHESTRATOR.md` if not already done
  - Ensure all stored state files use v2.0 format
- **References**:
  - `src/perception/object_registry.py` (lines 288-325, load_from_json method)

---

### 2025-11-22-1805 – Documented orchestrator snapshots, prompts, and ops guardrails

- **Owner**: AI Agent (docs refresh)
- **Agents affected**: TaskOrchestrator, ObjectTracker, ops playbook
- **Git commit(s)**: Based on efd3e0d18a970a65e72155bc4a27582aafee5e3e
- **Context**: Snapshot/perception pool work is now default-enabled with registry v2.0 and YAML prompt loading, but agent docs still referenced deprecated TaskParser/world_model pieces.
- **Actions**:
  - Updated `agents/design/architecture.md` with the current stack (PDDLDomainMaintainer + ContinuousObjectTracker + snapshots/registry v2.0) and a runnable orchestrator snippet.
  - Refreshed `agents/operations/playbook.md` to cover snapshot cadence/retention, YAML prompt usage, event-driven auto-save, and journal logging requirements.
  - Replaced `agents/design/orchestrator_observation_snapshot_plan.md` with the implemented behavior (default cadence, manifest/index shape, robot_state handling, retention notes).
  - Added `AGENTS.md` cross-links pointing to `src/planning/task_orchestrator.py`, `config/orchestrator_config.py`, and prompt YAML sources.
- **Result**: Agent docs now mirror current code paths and defaults; cross-links capture the source commit and files.
- **Next steps**: Run `examples/orchestrator_demo.py` with snapshots enabled to validate docs against runtime output in the next ops cycle.
- **References**: `agents/design/architecture.md`, `agents/operations/playbook.md`, `agents/design/orchestrator_observation_snapshot_plan.md`, `AGENTS.md`
